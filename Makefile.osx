EXEC	= gpuPlume

CC	= g++ -O2 -Wall -DNDEBUG

CSRC	= collectionBox.cpp \
	  displayControl.cpp \
	  framebufferObject.cpp \
	  Gaussian_2shaders_Model.cpp \
	  GaussianModel.cpp \
	  gpuPlume.cpp \
	  glErrorUtil.cpp \
	  GLSL.cpp \
	  MultipleBuildingsModel.cpp \
	  nonGaussianModel.cpp \
	  particleControl.cpp \
	  particleEmitter.cpp \
	  plumeControl.cpp \
	  pointEmitter.cpp \
	  Random.cpp \
	  ReflectionModel.cpp \
	  renderbuffer.cpp \
	  simulation.cpp \
	  sphereEmitter.cpp \
	  streamLine.cpp \
	  Timer.cpp \
	  util.cpp

COBJS   = $(CSRC:.cpp=.o)

# Currently not using the fortran code, so don't include
# PLUME_DIR = Modular_QUICPLUME
# FSRCS =	$(PLUME_DIR)/DataModule.f90 $(PLUME_DIR)/ReadFiles.f90
# FOBJS =  $(FSRCS:.f90=.o)
# FOBJSS = DataModule.o ReadFiles.o

LIB=-lGLEW -framework GLUT -framework OpenGL -framework Foundation
LIB_PATH=
INCLUDE_PATH=

# LIB=-Wl,-rpath=/home/cs/vr/software/glew-1.3.4.dist/lib -lGLEW -lglut -lGL 
# LIB_PATH=-L/home/cs/vr/software/glew-1.3.4.dist/lib
# INCLUDE_PATH=-I/home/cs/vr/software/glew-1.3.4.dist/include

# compile with gfortran
FCLOC	= /usr/local
FC	= $(FCLOC)/bin/gfortran
FCFLAGS	= -O3 -fdefault-double-8 -fdefault-real-8 -fdefault-integer-8 -ffree-form -ftree-vectorize

FLAGS = $(INCLUDE_PATH) $(LIB_PATH) $(LIB)

$(EXEC): $(COBJS) $(FOBJS)
	$(CC) -o $(EXEC) $(COBJS) $(FOBJSS) $(FLAGS) -L$(FCLOC)/lib -lgfortran

%.o : %.cpp
	$(CC) -c $(INCLUDE_PATH) $<

%.o : %.f90
	$(FC) $(FCFLAGS) -c $<

clean:
	rm -f $(EXEC) *.o
